{
  "name": "chan",
  "version": "0.3.0",
  "description": "A go style channel implementation that works nicely with co",
  "main": "chan.js",
  "scripts": {
    "test": "./node_modules/mocha/bin/mocha"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/brentburgoyne/chan"
  },
  "keywords": [
    "async",
    "go",
    "channel",
    "co",
    "generator"
  ],
  "author": {
    "name": "Brent Burgoyne"
  },
  "contributors": [
    {
      "name": "Brent Burgoyne"
    },
    {
      "name": "TJ Holowaychuk",
      "email": "tj@vision-media.ca"
    },
    {
      "name": "Eugene Ware",
      "email": "eugene@noblesamurai.com"
    }
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/brentburgoyne/chan/issues"
  },
  "homepage": "https://github.com/brentburgoyne/chan",
  "devDependencies": {
    "mocha": "~1.14.0",
    "expect.js": "~0.2.0",
    "co": "~2.3.0",
    "superagent": "~0.15.7",
    "co-wait": "0.0.0",
    "split": "~0.2.10"
  },
  "readme": "# Chan\n\nA [go](http://golang.org) style channel implementation that works well with [co](https://github.com/visionmedia/co).\n\n## Installation\n\n```bash\n$ npm install chan\n```\n## Usage\n\nChan does not directly use any ES6 Harmony features, but it is designed to work well with co, a control flow library based on ES6 generators. The following example uses co and requires `node 0.11.x` (unstable) and must be run with the `--harmony-generators` flag. Future stable versions of node.js will include support for generators.\n\n```javascript\n// require the dependencies\nvar chan = require('chan')\n  , co   = require('co')\n  , fs   = require('fs');\n\n// make a new channel\nvar ch = chan();\n\n// execute a co generator\nco(function *() {\n  \n  // pass the channel as the callback to filesystem read file function\n  // this will push the file contents in to the channel\n  fs.readFile(__dirname + '/README.markdown', ch);\n\n  // yield the channel to pull the value off the channel\n  var contents = yield ch;\n\n  // use the value\n  console.log(String(contents));\n\n})();\n```\n\nYou can also wait for a message to be ready on multiple channels (the golang equivalent of the `select` statement:\n\n``` javascript\nvar chan = require('chan')\n  , co   = require('co');\n\n// make two channels\nvar ch1 = chan()\n  , ch2 = chan();\n\nco(function *() {\n  // will block until there is data on either ch1 or ch2,\n  // and will return the channel with data\n  // if data is on both channels, a channel will be selected at random\n  switch (yield chan.select(ch1, ch2)) {\n    \n    // channel 1 received data\n    case ch1:\n      // retrieve the message yielded by the channel\n      console.log(yield ch1.selected);\n      break;\n\n    // channel 2 received data\n    case ch2:\n      // retrieve the message yielded by the channel\n      console.log(yield ch2.selected);\n      break;\n  }\n})();\n\n// put 42 onto channel 1\nch1(42);\n```\n",
  "readmeFilename": "README.markdown",
  "_id": "chan@0.3.0",
  "_from": "chan@~0.3.0"
}
